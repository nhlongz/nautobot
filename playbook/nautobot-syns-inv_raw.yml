### Playbook to bootstrap netbox inventory with a list of juniper devices provided by static inventory file
# Uses ansible gather_facts to grab net_version, serial number and net_model
# Also perform a dig to get a FQDN which we can use as device name instead of the inventory_name

---
- name: PB to Bootstrap Netbox Inventory
  hosts: site03
  gather_facts: True
  vars:
    #ansible_user:
    #ansible_ssh_private_key_file:
    url: 'http://192.168.65.150:8088/'
    token: 'cff1dc834c369b08dc02c0fa04e1e1e89dd7bb43'
    platform: "{{ ansible_network_os }}"
    site: "{{ site_name }}"
    device_role: "{{ role_group }}"
    Name_device: ""
    Conected_device: ""
    temp: ""
  tasks:
#------- set hostname---------#

  - name: set hostname
    cisco.ios.ios_hostname:
      config:
        hostname: "{{ inventory_hostname }}"
      state: merged
#------- ansible colected infomation hosts. ------#
  - name: "Check if net_version exists"
    ### If ansible_facts does not provide net_version we manually fill it in as unknown
    set_fact:
      net_version: "unknown"
      cacheable: yes
    when: ansible_facts['net_version'] is undefined

  - name: "Check if net_model exists"
    ### If ansible_facts does not provide net_model we manually fill it in as unknown
    ansible.builtin.set_fact:
      net_model: "{{ ansible_facts['net_version'] }}"
      cacheable: yes
    when: ansible_facts['net_model'] is undefined
    
  - name: "Assign net version"
    set_fact:
      net_version: "{{ ansible_facts['net_version'] }}"
    when: ansible_facts['net_version'] is defined

  ### Optional
  - name: "Resolve FQDN Hostname - perform DIG"
    ### Perform linux DIG command to get the reverse DNS record for the IP. THis will be our new hostname for netbox
    raw: "dig -x {{ ansible_host }} +short | sed -e 's/.$//'"
    register: dig_result
    delegate_to: localhost

  ### Optional
  - name: "TASK 11: Assign dig result to fqdn var"
    ### If Reverse DNS exists, trim whhite spaces and assing to var
    set_fact:
      fqdn: "{{ dig_result.stdout_lines[0] | trim}}"
    when: dig_result.stdout_lines[0] is defined

  ### Optional
  - name: "TASK 12: If no dig result, assign placeholder fqdn value"
    ### If no reverse DNS, then set a inventory hostname and IP as the hostname
    set_fact:
      fqdn: "{{ inventory_hostname }}-no-dns-{{ ansible_host }}"
    when: dig_result.stdout_lines[0] is undefined

#-------- ansible create and update infomation from ansible_colected to nautobot------#
# create manufacturer, device_type, site, device_role, platporm, region,rack.
  - name: Create manufacturer within Nautobot with only required information
    ignore_errors: yes
    networktocode.nautobot.manufacturer:
      url: "{{ url }}"
      token: "{{ token }}"
      name: "{{ manu }}"
      state: present
    delegate_to: localhost
  - name: Create device_type within Nautobot with only required information
    ignore_errors: yes
    networktocode.nautobot.device_type:
      url: "{{ url }}"
      token: "{{ token }}"
      slug: "{{ ansible_facts['net_model'] }}"
      model: "{{ ansible_facts['net_model'] }}"
      manufacturer: "{{ manu }}"
      state: present
    delegate_to: localhost
  - name: Create region_zone within Nautobot with only required information
    ignore_errors: yes
    networktocode.nautobot.region:
      url: "{{ url }}"
      token: "{{ token }}"
      name: "{{ site_zone }}"
      state: present
    delegate_to: localhost
  - name: Create region within Nautobot with only required information
    ignore_errors: yes
    networktocode.nautobot.region:
      url: "{{ url }}"
      token: "{{ token }}"
      name: "{{ site_Region }}"
      parent_region: "{{ site_zone }}"
      state: present
    delegate_to: localhost
  - name: Create site within Nautobot with only required information
    ignore_errors: yes
    networktocode.nautobot.site:
      url: "{{ url }}"
      token: "{{ token }}"
      name: "{{ site }}"
      region: "{{ site_Region }}"
      status: active
      state: present
    delegate_to: localhost
  - name: Create device role within Nautobot with only required information
    ignore_errors: yes
    networktocode.nautobot.device_role:
      url: "{{ url }}"
      token: "{{ token }}"
      name: "{{ device_role }}"
      color: "{{ role_color }}"
      state: present
    delegate_to: localhost
  - name: Create platform within Nautobot with only required information
    ignore_errors: yes
    networktocode.nautobot.platform:
      url: "{{ url }}"
      token: "{{ token }}"
      name: "{{ platform }}"
      state: present
    delegate_to: localhost
  - name: Create rack within Nautobot with only required information
    ignore_errors: yes
    networktocode.nautobot.rack:
      url: "{{ url }}"
      token: "{{ token }}"
      name: "Rack_{{ site }}"
      site: "{{ site }}"
      status: active
      state: present
    delegate_to: localhost

  - set_fact:
      Name_device: "{{ inventory_hostname }}-{{ site_name }}" 

#####---- create devices ------######
  - name: Create device within Nautobot with only required information
    networktocode.nautobot.device:
      url: "{{ url }}"
      token: "{{ token }}"
      name: "{{ Name_device }}"
      asset_tag: "{{ fqdn }}"
      platform: "{{ platform }}"
      device_type: "{{ ansible_facts['net_model'] }}"
      device_role: "{{ device_role }}"
      site: "{{ site }}"
      serial: "{{ ansible_facts['net_serialnum'] }}"
      custom_fields:
        firmware_version: "{{ net_version }}"
      status: active
      state: present
    delegate_to: localhost

    ### this interface will be used as the primary IP and interface for the device
  - name: Create interface within Nautobot with only required information
    networktocode.nautobot.device_interface:
      url: "{{ url }}"
      token: "{{ token }}"
      device: "{{ Name_device }}"
      name: "{{ item.key }}" 
      mac_address: "{{ item.value.macaddress }}"
      mtu: "{{ item.value.mtu }}"
      type: "virtual"
      state: present
      validate_certs: no
    with_dict:   "{{ ansible_facts.net_interfaces }}"
    delegate_to: localhost

  - name: "Add IP address of ansible host to IPAM"
#networktocode.nautobot.ip_address:
    networktocode.nautobot.ip_address:
      url: "{{ url }}"
      token: "{{ token }}"
      address: "{{ ansible_host }}"
      status: active
      assigned_object:
        name: "{{ item.key }}" 
        device: "{{ Name_device }}"
      state: present
      validate_certs: no
    when: item.value.ipv4.0.address is defined and item.value.ipv4.0.address == ansible_host
    with_dict:   "{{ ansible_facts.net_interfaces }}"
    delegate_to: localhost

# set primary ip.
  - name: "Assign ansible_host IP as the primary interface for the device"
    networktocode.nautobot.device:
      url: "{{ url }}"
      token: "{{ token }}"
      name: "{{ Name_device }}"
      platform: "{{ platform }}"
      device_type: "{{ ansible_facts['net_model'] }}"
      device_role: "{{ device_role }}"
      site: "{{ site }}"
      serial: "{{ ansible_facts['net_serialnum'] }}"
      primary_ip4: "{{ ansible_host }}/32"
      custom_fields:
        firmware_version: "{{ net_version }}"
      status: active
      state: present
    delegate_to: localhost

# add devices to the rack. 

  - name: "Update the rack and position of an existing device" 
    ignore_errors: yes
    networktocode.nautobot.device:
      url: "{{ url }}"
      token: "{{ token }}"
      name: "{{ Name_device }}"
      rack: "Rack_{{ site }}"
      position: "{{ item }}"
      face: Front
      status: active
      state: present
    register: put_status
    retries: 1
    delay: 5
    loop: [38, 36, 34 ,32, 30,28,26]
    until: put_status.changed == true
    delegate_to: localhost
#    until: put_status.rc | default('') == 0 

#  - block:
#    - set_fact:
#        temp: "{{ item.value.0.host|map(split,'.') }}"
#        Conected_device: "{{ temp[0] }}-{{ site_name }}"
  - name: Create cable within Nautobot with only required information
    networktocode.nautobot.cable:
      url: "{{ url }}"
      token: "{{ token }}"
      termination_a_type: "dcim.interface"
      termination_a:
        device: "{{ Name_device }}"
        name: "{{ item.key }}"
      termination_b_type: "dcim.interface"
      termination_b:
        device: "{{ item.value.0.host | map(split,'.') | first }}-{{ site_name }}" #"{{ item.0.host|split('.')[0] }}"   #{{ 'sarav@gritfy.com'|split('@')}}
        name: "{{ item.value.0.port }}"
      status: active
      state: present
    with_dict:   "{{ ansible_facts.net_neighbors }}"
    delegate_to: localhost
#    when: item.value.ipv4.0.address is defined and item.value.ipv4.0.address == ansible_host

#     with_dict:   "{{ ansible_facts.net_neighbors }}"
# "{{ ansible_facts.net_neighbors|dict2items }}"      